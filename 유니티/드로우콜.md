# 드로우 콜

## 개요
__CPU가 GPU에게 렌더링 작업을 수행하도록 명령하는 것__

CPU(메시정보, 텍스처 정보, 쉐이더 정보, 트랜스폼 정보, 알파 블렌딩 여부, 기타) --드로우콜 (명령)-> GPU(렌더링)

## 발생 조건
화면에 게임 오브젝트를 그리려면 엔진이 그래픽스 API(OpenGL, Direct3D 등)에 드로우 콜을 보내야 한다. 드로우 콜에는 종종 리소스가 많이 사용되고, 그래픽스 API가 모든 드로우 콜에 중요 작업을 수행함으로 인해 CPU 성능이 많이 사용될 수 있다. 이 이유는 주로 드로우 콜 간에 수행되는(다른 머티리얼로 전환하는 등의) 스테이트 변경으로 인해 그래픽 드라이버에서 리소스가 많이 사용되는 확인 및 이동 단계를 수행해야 되기 때문이다.

오브젝트 하나를 그릴 때 메시 1개, 머티리얼도 1개로 이루어져있다면 배치는 1회이다(드로우콜 한번). 하나의 오브젝트가 여러 파츠로 나눠져있고, 메시가 여러개이면 하나의 머티리얼로 공유했다고 해도 파츠 수 만큼 드로우콜이 발생한다. 즉, 이러한 오브젝트가 여러개라면 오브젝트 갯수 X 파츠 갯수 만큼의 드로우 콜이 불리게 된다. 또한 메시가 여러개인 경우말고도 머티리얼이 여러개인 경우, 툰쉐이딩 처럼 외각선을 그리기위해 멀티패스로 이루어져있는 쉐이더를 사용하면 두번의 드로우 콜이 발생한다.

## 배칭
__동일한 머터리얼을 공유하는 오브젝트들을 묶어서 드로우콜하는 기법__  
단, 동일한 머터리얼을 공유하는 오브젝트만 배칭할 수 있음

## 유니티에서의 해결방법
1. __동적 배칭__: 메시가 충분히 작은 경우 이 기법을 사용하면 메시의 버텍스가 CPU에서 트랜스폼되고, 여러 유사한 메시가 그룹화되고, 모든 것이 한꺼번에 드로우된다.
    - 사용하려면 몇 가지 조건이 필요하지만 알아서 적용이 된다.
    - 하지만, 효율이 뛰어나진 않다.
2. __정적 배칭__: 정적인(움직이지 않는) 게임 오브젝트를 큰 메시로 합치고 더 빠른 방법으로 렌더링한다.
    - 오브젝트의 위치, 회전, 스케일 값의 변동이 없어야 하며, static으로 명시적 설정을 한다.
    - 구조물 같은 오브젝트 설정에 적합하며 동적할당보다 효과가 좋다.
    - 하지만, 메모리가 많이 필요하다. 즉, 과도하게 많은 오브젝트를 사용할 때는 피해야 한다.

## 최적화 기법
1. __텍스쳐 아틀라스__
    - 여러 이미지들을 한 묶음으로 만드는 것
    - UGUI: Sprite Packer
    - NGUI: Atls maker
    - 동일 머터리얼을 고유하면 드로우 콜을 줄일 수 있음 -> 아틀라스로 텍스쳐들을 하나로 묶어주면 머터리얼들을 일괄적으로 처리 가능
2. __라이트 맵__
    - 빛과 관련된 실시간 연산이 성능에 부담되므로 미리 맵을 이미지로 만드는 것
    - 미리 Baked하는 것, 맵을 굽는 데 있어서 오래 걸리지만 성능 개선엔 탁월함
3. __오클루젼 컬링__
    - 완전히 가려진 오브젝트의 렌더링을 무효화 하는 것
    
## 출처

[Unity 메뉴얼](https://docs.unity3d.com/kr/2019.4/Manual/DrawCallBatching.html)
[DrawCall 최적화 기법](https://blog.naver.com/PostView.nhn?blogId=sabotduke&logNo=220794695469)
